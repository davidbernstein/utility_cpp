/* * Copyright (C) 2004-2018 David Bernstein <david.h.bernstein@gmail.com> * * This file is part of utility_cpp. * * utility_cpp is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * utility_cpp is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with utility_cpp.  If not, see <http://www.gnu.org/licenses/>.*/#include "xydisplay.h"#include "vtkDoubleArray.h"#include "vtkPointData.h"#include "vtkDataObject.h"#include "vtkPolyDataMapper.h"#include "vtkJPEGWriter.h"#include "vtkPostScriptWriter.h"#include "vtkWindowToImageFilter.h"#include "vtkProperty2D.h"using namespace utility;using utility std;XYDisplay::XYDisplay(short numCurves){	mpVtkDataObject.SetSize(numCurves);	mpVtkFieldData.SetSize(numCurves);		mpVtkXYPlotActor = vtkXYPlotActor::New();  		for (short i = 0; i < numCurves; ++i) {		mpVtkDataObject[i] = vtkDataObject::New();		mpVtkFieldData[i] = vtkFieldData::New();				mpVtkDataObject[i]->SetFieldData(mpVtkFieldData[i]);		mpVtkXYPlotActor->AddDataObjectInput(mpVtkDataObject[i]);	}	       mpVtkRenderWindow = vtkRenderWindow::New();    mpVtkRenderer = vtkRenderer::New();     mpVtkRenderer->AddActor2D(mpVtkXYPlotActor);        // white    mpVtkRenderer->SetBackground(1.0, 1.0, 1.0);        // light green    //mpVtkRenderer->SetBackground(0.95, 1.0, 0.95);    mpVtkRenderWindow->AddRenderer(mpVtkRenderer);    mpVtkRenderWindow->SetSize(400, 400);    mpVtkRenderWindow->SetPosition(500, 50);    // properties     mpVtkXYPlotActor->SetXValuesToValue();    mpVtkXYPlotActor->SetDataObjectXComponent(0, 0);    mpVtkXYPlotActor->SetDataObjectYComponent(0, 1);    mpVtkXYPlotActor->SetWidth(0.9);    mpVtkXYPlotActor->SetHeight(0.9);    mpVtkXYPlotActor->SetPosition(0.05, 0.05);    mpVtkXYPlotActor->GetProperty()->SetColor(0, 0, 0);    mpVtkXYPlotActor->GetProperty()->SetLineWidth(1);        // position of plot in plot window    //mpVtkXYPlotActor->GetPositionCoordinate()->SetValue(0.0, 0.67, 0.0);    //mpVtkXYPlotActor->GetPosition2Coordinate()->SetValue(1.0, 0.33, 0.0);        return;}XYDisplay::~XYDisplay(){	long numCurves = mpVtkDataObject.Size();	for (long i = 0; i < numCurves; ++i) {		mpVtkDataObject[i]->Delete();		mpVtkFieldData[i]->Delete();	}	    mpVtkXYPlotActor->Delete();        mpVtkRenderer->Delete();    mpVtkRenderWindow->Delete();        return;}void XYDisplay::Show(const XYData &data){	// load data    Load(data);       // render window    mpVtkRenderWindow->Render();        	return;}void XYDisplay::Load(const XYData &data){	long numCurves = data.NumColumns();		for (short j = 0; j < numCurves; ++j) {		mpVtkFieldData[j]->Initialize();		mpVtkFieldData[j]->AllocateArrays(2);			vector<double> xValues = data.GetXValues();		vector<double> yValues = data.GetYValues(j+1);   		// set x values		vtkDataArray *pVtkXDataArray = vtkDataArray::CreateDataArray(VTK_FLOAT);		pVtkXDataArray->SetNumberOfTuples(xValues.size());		for (long i = 0; i < xValues.size(); ++i) 			pVtkXDataArray->SetTuple(i, &xValues[i]);			vtkDataArray* pVtkYDataArray = vtkDataArray::CreateDataArray(VTK_FLOAT);		pVtkYDataArray->SetNumberOfTuples(xValues.size());	 			for (long i = 0; i < xValues.size(); ++i) 			pVtkYDataArray->SetTuple(i, &yValues[i]);			mpVtkFieldData[j]->AddArray(pVtkXDataArray);		mpVtkFieldData[j]->AddArray(pVtkYDataArray);		// clean up		pVtkXDataArray->Delete();		pVtkYDataArray->Delete();	}	    return;}void XYDisplay::SetXAxisRange(double xMin, double xMax){	mpVtkXYPlotActor->SetXRange(xMin, xMax);	return;}void XYDisplay::SetYAxisRange(double yMin, double yMax){	mpVtkXYPlotActor->SetYRange(yMin, yMax);	return;}void XYDisplay::SetTitle(std::string title){    mpVtkXYPlotActor->SetTitle(title.c_str());	return;}void XYDisplay::SetXTitle(std::string xTitle){	mpVtkXYPlotActor->SetXTitle(xTitle.c_str());	return;}void XYDisplay::SetYTitle(std::string yTitle){    mpVtkXYPlotActor->SetYTitle(yTitle.c_str());	return;}void XYDisplay::SaveAsJPEG(const string fileName) const{    vtkJPEGWriter *pVtkJPEGWriter = vtkJPEGWriter::New();    vtkWindowToImageFilter *pVtkWindowToImageFilter = vtkWindowToImageFilter::New();        pVtkWindowToImageFilter->SetInput(mpVtkRenderWindow);        pVtkJPEGWriter->SetInput(pVtkWindowToImageFilter->GetOutput());    pVtkJPEGWriter->SetFileName(fileName.c_str());    pVtkJPEGWriter->Write();        pVtkJPEGWriter->Delete();    pVtkWindowToImageFilter->Delete();        return;}void XYDisplay::SaveAsPostscript(const string fileName) const{    vtkPostScriptWriter *pVtkPostScriptWriter = vtkPostScriptWriter::New();    vtkWindowToImageFilter *pVtkWindowToImageFilter = vtkWindowToImageFilter::New();        pVtkWindowToImageFilter->SetInput(mpVtkRenderWindow);        pVtkPostScriptWriter->SetInput(pVtkWindowToImageFilter->GetOutput());    pVtkPostScriptWriter->SetFileName(fileName.c_str());    pVtkPostScriptWriter->Write();        pVtkPostScriptWriter->Delete();    pVtkWindowToImageFilter->Delete();        return;}